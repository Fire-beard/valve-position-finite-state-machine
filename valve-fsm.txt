//state machine that reads IO and handles valve opened, closed, and transition
//with failed to open and failed to close states based on timers/

#include <stdio.h>
#include <unistd.h>
#include <stbool.h>

enum valve_state {
    CLOSED = 0,
    OPENED,
    TRANSITION,
    FAILED_TO_OPEN,
    FAILED_TO_CLOSE
    MAXIMUM_STATE_VAL /*this represents the maximum state
};
enum valve_event {
    TIMER_EXPIRED = 0,
    OPEN_COMMAND,
    CLOSE_COMMAND
    MAXIMUM_STATE_VAL /*this represents the maximum state 
};

//bitfield that lights up panelboard indicator lights
struct ind_light_bitfield {
	u8_t light_closed : 1;
	u8_t light_opened : 1;
	u8_t light_transition : 1;
	u8_t light_failedtoclose : 1;
	u8_t light_failedtoopen : 1;
};

enum valve_state valve_fsm(enum valve_state current_state, enum valve_event event, int timer_expired) {
    switch (current_state) {
    case CLOSED:
        if (event == OPEN_COMMAND) {
            return TRANSITION;
	    
        }
        break;
    case OPENED:
        if (event == CLOSE_COMMAND) {
            return TRANSITION;
        }
        break;
    case TRANSITION:
        if (timer_expired) {
            if (event == OPEN_COMMAND) {
                return FAILED_TO_OPEN;
            } else if (event == CLOSE_COMMAND) {
                return FAILED_TO_CLOSE;
            }
        } else if (event == TIMER_EXPIRED) {
            if (current_state == TRANSITION && event == OPEN_COMMAND) {
                return OPENED;
            } else if (current_state == TRANSITION && event == CLOSE_COMMAND) {
                return CLOSED;
            }
        }
        break;
    case FAILED_TO_OPEN:
    case FAILED_TO_CLOSE:
	// Handle error
        break;
    default:
        return CLOSED;
    }
    return current_state;
}

#define LED_CLOSED 0
#define LED_OPEN 1
{
	switch(valve_state)
	case CLOSED: /*valve closed, CLOSED ind light on*/
		struct ind_light_bitfield = {0};
		bf.light_closed = 1;
		break;
	case OPENED: /*valve opened, opened ind light on*/
		struct ind_light_bitfield = {0};
		bf.light_opened = 1;	
		break;
	case TRANSITION: /*valve transition, ind light on*/
		struct ind_light_bitfield = {0};
		bf.light_transition = 1;
		break;
	case FAILED_TO_OPEN: /*valve failed to open, ind light on*/
		struct ind_light_bitfield = {0};
		bf.light_failedtoopen = 1;
		break;
	case FAILED_TO_CLOSE: /*valve failed to close, ind light on*/
		struct ind_light_bitfield = {0};
		bf.light_failedtoclose = 1;
		break;
}

int main(void) {
    enum valve_state state = CLOSED;
    enum valve_event event;
    int timer_expired = 0;

    while (1) {
        printf("Current state: %d\n", state);
        sleep(1); // Simulate timer expiration
        timer_expired = 1; // Simulate timer expiration

        // Simulate events
        if (state == CLOSED) {
            event = OPEN_COMMAND;
        } else if (state == OPENED) {
            event = CLOSE_COMMAND;
        } else {
            event = TIMER_EXPIRED;
        }

        state = valve_fsm(state, event, timer_expired);
	ind_lights(valve_state)
    }

    return 0;
}

